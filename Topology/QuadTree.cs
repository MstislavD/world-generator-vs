using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Topology
{
    /// <summary>
    /// Interface implemented by polygons and used in quad tree point location algorithm. Generated by DeepSeek.
    /// </summary>
    public interface IPolygon
    {
        public IEnumerable<Vector2> Vertices { get; }
        public BoundingBox Bounds { get => Bounds ?? CalculateBoundingBox(); private set => Bounds = value; }
        public int VertexCount { get; }

        private BoundingBox CalculateBoundingBox()
        {
            if (Vertices == null || VertexCount == 0)
            {
                Bounds = new BoundingBox(0, 0, 0, 0);
                return Bounds;
            }               

            double minX = Vertices.First().X;
            double maxX = Vertices.First().X;
            double minY = Vertices.First().Y;
            double maxY = Vertices.First().Y;

            foreach (var vertex in Vertices)
            {
                minX = Math.Min(minX, vertex.X);
                maxX = Math.Max(maxX, vertex.X);
                minY = Math.Min(minY, vertex.Y);
                maxY = Math.Max(maxY, vertex.Y);
            }

            Bounds = new BoundingBox(minX, minY, maxX, maxY);
            return Bounds;
        }

        // Ray casting algorithm for point-in-polygon test
        public bool ContainsPoint(Vector2 point)
        {
            if (!Bounds.Contains(point))
                return false;

            bool inside = false;
            Vector2 v1 = Vertices.Last(); // OPTIMIZATION POSSIBLE

            foreach (Vector2 v2 in Vertices)
            {
                if ((v2.Y > point.Y) != (v1.Y > point.Y) &&
                    point.X < (v1.X - v2.X) * (point.Y - v2.Y) / (v1.Y - v2.Y) + v2.X)
                {
                    inside = !inside;
                }
                v1 = v2;
            }

            return inside;
        }
    }

    public class BoundingBox
    {
        public double MinX { get; set; }
        public double MinY { get; set; }
        public double MaxX { get; set; }
        public double MaxY { get; set; }

        public BoundingBox(double minX, double minY, double maxX, double maxY)
        {
            MinX = minX;
            MinY = minY;
            MaxX = maxX;
            MaxY = maxY;
        }

        public bool Contains(Vector2 point)
        {
            return point.X >= MinX && point.X <= MaxX &&
                   point.Y >= MinY && point.Y <= MaxY;
        }

        public bool Intersects(BoundingBox other)
        {
            return !(MinX > other.MaxX || MaxX < other.MinX ||
                     MinY > other.MaxY || MaxY < other.MinY);
        }
    }

    // Quadtree node for spatial partitioning
    public class QuadtreeNode
    {
        public BoundingBox Bounds { get; set; }
        public List<IPolygon> Polygons { get; set; }
        public QuadtreeNode[] Children { get; set; }
        public int Capacity { get; set; }
        public bool IsDivided { get; set; }

        public QuadtreeNode(BoundingBox bounds, int capacity)
        {
            Bounds = bounds;
            Capacity = capacity;
            Polygons = new List<IPolygon>();
            Children = new QuadtreeNode[4];
            IsDivided = false;
        }

        public void Insert(IPolygon polygon)
        {
            if (!Bounds.Intersects(polygon.Bounds))
                return;

            if (Polygons.Count < Capacity)
            {
                Polygons.Add(polygon);
            }
            else
            {
                if (!IsDivided)
                    Subdivide();

                foreach (var child in Children)
                {
                    child.Insert(polygon);
                }
            }
        }

        private void Subdivide()
        {
            double halfWidth = (Bounds.MaxX - Bounds.MinX) / 2;
            double halfHeight = (Bounds.MaxY - Bounds.MinY) / 2;
            double midX = Bounds.MinX + halfWidth;
            double midY = Bounds.MinY + halfHeight;

            Children[0] = new QuadtreeNode(new BoundingBox(Bounds.MinX, Bounds.MinY, midX, midY), Capacity);
            Children[1] = new QuadtreeNode(new BoundingBox(midX, Bounds.MinY, Bounds.MaxX, midY), Capacity);
            Children[2] = new QuadtreeNode(new BoundingBox(Bounds.MinX, midY, midX, Bounds.MaxY), Capacity);
            Children[3] = new QuadtreeNode(new BoundingBox(midX, midY, Bounds.MaxX, Bounds.MaxY), Capacity);

            IsDivided = true;

            // Redistribute polygons to children
            foreach (var polygon in Polygons)
            {
                foreach (var child in Children)
                {
                    child.Insert(polygon);
                }
            }
            Polygons.Clear();
        }

        public List<IPolygon> Query(Vector2 point)
        {
            var candidates = new List<IPolygon>();
            Query(point, candidates);
            return candidates;
        }

        private void Query(Vector2 point, List<IPolygon> candidates)
        {
            if (!Bounds.Contains(point))
                return;

            if (IsDivided)
            {
                foreach (var child in Children)
                {
                    child.Query(point, candidates);
                }
            }
            else
            {
                candidates.AddRange(Polygons);
            }
        }
    }

    // Main spatial index class
    public class PolygonSpatialIndex
    {
        private QuadtreeNode _root;
        private List<IPolygon> _allPolygons;

        public PolygonSpatialIndex(List<IPolygon> polygons, BoundingBox worldBounds, int quadtreeCapacity = 4)
        {
            _allPolygons = polygons;
            _root = new QuadtreeNode(worldBounds, quadtreeCapacity);

            foreach (var polygon in polygons)
            {
                _root.Insert(polygon);
            }
        }

        public IPolygon FindPolygonContainingPoint(Vector2 point)
        {
            // First, get candidate polygons using quadtree
            var candidates = _root.Query(point);

            // Then perform precise point-in-polygon tests
            foreach (var polygon in candidates)
            {
                if (polygon.ContainsPoint(point))
                    return polygon;
            }

            return null; // No polygon contains the point
        }

        // Alternative method without spatial index (for comparison)
        public IPolygon FindPolygonContainingPointBruteForce(Vector2 point)
        {
            foreach (var polygon in _allPolygons)
            {
                if (polygon.ContainsPoint(point))
                    return polygon;
            }
            return null;
        }
    }

    // Example usage
    //class Program
    //{
    //    static void Main()
    //    {
    //        // Create sample polygons
    //        var polygons = new List<IPolygon>
    //    {
    //        new IPolygon(1, new List<Vector2>
    //        {
    //            new Vector2(0, 0), new Vector2(5, 0), new Vector2(5, 5), new Vector2(0, 5)
    //        }),
    //        new IPolygon(2, new List<Vector2>
    //        {
    //            new Vector2(6, 1), new Vector2(10, 1), new Vector2(8, 8), new Vector2(6, 6)
    //        }),
    //        new IPolygon(3, new List<Vector2>
    //        {
    //            new Vector2(12, 2), new Vector2(15, 2), new Vector2(15, 7), new Vector2(12, 7)
    //        })
    //    };

    //        // Create spatial index with world bounds and capacity
    //        var worldBounds = new BoundingBox(0, 0, 20, 20);
    //        var spatialIndex = new PolygonSpatialIndex(polygons, worldBounds, 4);

    //        // Test points
    //        var testPoints = new[]
    //        {
    //        new Vector2(2, 2),   // Should be in polygon 1
    //        new Vector2(7, 3),   // Should be in polygon 2
    //        new Vector2(13, 4),  // Should be in polygon 3
    //        new Vector2(18, 18)  // Should not be in any polygon
    //    };

    //        foreach (var point in testPoints)
    //        {
    //            var polygon = spatialIndex.FindPolygonContainingPoint(point);
    //            if (polygon != null)
    //            {
    //                Console.WriteLine($"Point ({point.X}, {point.Y}) is in polygon {polygon.Id}");
    //            }
    //            else
    //            {
    //                Console.WriteLine($"Point ({point.X}, {point.Y}) is not in any polygon");
    //            }
    //        }
    //    }
    //}
}
