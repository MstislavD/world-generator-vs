using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;
using static System.Net.Mime.MediaTypeNames;

namespace Topology
{
    public interface ISpatialIndex<TPolygon>
    {
        TPolygon? FindPolygonContainingPoint(double x, double y);
    }

    // Quadtree node for spatial partitioning
    class QuadtreeNode<TPolygon>
        where TPolygon : IPolygon
    {
        static readonly int _maxDepth = 100;
        public BoundingBox Bounds { get; set; }
        public List<TPolygon> Polygons { get; set; }
        public QuadtreeNode<TPolygon>[] Children { get; set; }
        public int Capacity { get; set; }
        public bool IsDivided { get; set; }

        public QuadtreeNode(BoundingBox bounds, int capacity)
        {
            Bounds = bounds;
            Capacity = capacity;
            Polygons = new List<TPolygon>();
            Children = new QuadtreeNode<TPolygon>[4];
            IsDivided = false;
        }

        public void Insert(TPolygon polygon, int depth = 0)
        {
            if (depth > _maxDepth)
                throw new Exception("Quad tree max depth is reached.");

            if (!Bounds.Intersects(polygon.Bounds))
                return;

            if (!IsDivided && Polygons.Count < Capacity)
            {
                Polygons.Add(polygon);
            }
            else
            {
                if (!IsDivided)
                    Subdivide();

                foreach (var child in Children)
                {
                    child.Insert(polygon, depth + 1);
                }
            }
        }

        private void Subdivide()
        {
            double halfWidth = (Bounds.MaxX - Bounds.MinX) / 2;
            double halfHeight = (Bounds.MaxY - Bounds.MinY) / 2;
            double midX = Bounds.MinX + halfWidth;
            double midY = Bounds.MinY + halfHeight;

            Children[0] = new QuadtreeNode<TPolygon>(new BoundingBox(Bounds.MinX, Bounds.MinY, midX, midY), Capacity);
            Children[1] = new QuadtreeNode<TPolygon>(new BoundingBox(midX, Bounds.MinY, Bounds.MaxX, midY), Capacity);
            Children[2] = new QuadtreeNode<TPolygon>(new BoundingBox(Bounds.MinX, midY, midX, Bounds.MaxY), Capacity);
            Children[3] = new QuadtreeNode<TPolygon>(new BoundingBox(midX, midY, Bounds.MaxX, Bounds.MaxY), Capacity);

            IsDivided = true;

            // Redistribute polygons to children
            foreach (var polygon in Polygons)
            {
                foreach (var child in Children)
                {
                    child.Insert(polygon);
                }
            }
            Polygons.Clear();
        }

        public List<TPolygon> Query(Vector2 point)
        {
            var candidates = new List<TPolygon>();
            Query(point, candidates);
            return candidates;
        }

        private void Query(Vector2 point, List<TPolygon> candidates)
        {
            if (!Bounds.Contains(point))
                return;            

            if (IsDivided)
            {
                foreach (var child in Children)
                {
                    child.Query(point, candidates);
                }
            }
            else
            {
                candidates.AddRange(Polygons);
            }                
        }

        public override string ToString()
        {
            return $"Bounding box: {Bounds}, Polygons: {Polygons.Count}";
        }
    }

    /// <summary>
    /// Main spatial index class. Generated by DeepSeek.
    /// </summary>
    /// <typeparam name="TPolygon"></typeparam>
    public class QuadTreeSpatialIndex<TPolygon> : ISpatialIndex<TPolygon>
        where TPolygon : IPolygon
    {
        private QuadtreeNode<TPolygon> _root;

        public QuadTreeSpatialIndex(IEnumerable<TPolygon> polygons, BoundingBox worldBounds, int quadtreeCapacity = 4)
        {
            _root = new QuadtreeNode<TPolygon>(worldBounds, quadtreeCapacity);

            foreach (var polygon in polygons)
            {
                _root.Insert(polygon);
            }
        }

        public TPolygon? FindPolygonContainingPoint(double x, double y)
        {
            Vector2 point = new Vector2(x, y);
            // First, get candidate polygons using quadtree
            var candidates = _root.Query(point);

            // Then perform precise point-in-polygon tests
            foreach (var polygon in candidates)
            {
                if (Polygon.ContainsPoint(polygon, point))
                    return polygon;
            }

            return default; // No polygon contains the point
        }
    }

    public static class PolygonSpatialIndexBruteForce<TPolygon>
       where TPolygon : IPolygon
    {
        // Alternative method without spatial index (for comparison)
        public static TPolygon? FindPolygonContainingPoint(List<TPolygon> polygons, double x, double y)
        {
            Vector2 point = new Vector2(x, y);
            foreach (var polygon in polygons)
            {
                if (Polygon.ContainsPoint(polygon, point))
                    return polygon;
            }
            return default;
        }
    }
}
