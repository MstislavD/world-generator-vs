using System.Drawing;

namespace Topology
{
    /// <summary>
    /// Interface implemented by polygons and used in quad tree point location algorithm. Generated by DeepSeek.
    /// </summary>
    public interface IPolygon
    {
        public IEnumerable<Vector2> Vertices { get; }
        public BoundingBox Bounds { get; }
        public int VertexCount { get; }
        public bool ContainsPoint(Vector2 point);
    }

    public abstract class PolygonBase : IPolygon
    {
        BoundingBox? _bbox = null;
        public abstract IEnumerable<Vector2> Vertices { get; }
        public abstract int VertexCount { get; }

        public BoundingBox Bounds
        {
            get
            {
                if (_bbox == null)
                    _bbox = CalculateBoundingBox();
                return _bbox;
            }
            private set => _bbox = value;
        }

        private BoundingBox CalculateBoundingBox()
        {
            if (Vertices == null || VertexCount == 0)
            {
                return new BoundingBox(0, 0, 0, 0);
            }

            double minX = Vertices.First().X;
            double maxX = Vertices.First().X;
            double minY = Vertices.First().Y;
            double maxY = Vertices.First().Y;

            foreach (var vertex in Vertices)
            {
                minX = Math.Min(minX, vertex.X);
                maxX = Math.Max(maxX, vertex.X);
                minY = Math.Min(minY, vertex.Y);
                maxY = Math.Max(maxY, vertex.Y);
            }

            return new BoundingBox(minX, minY, maxX, maxY);
        }

        /// <summary>
        /// Ray casting algorithm for point-in-polygon test
        /// </summary>
        /// <param name="point"></param>
        /// <returns></returns>
        public bool ContainsPoint(Vector2 point)
        {
            if (!Bounds.Contains(point))
                return false;

            bool inside = false;
            Vector2 v1 = Vertices.First();

            foreach (Vector2 v2 in Vertices.Skip(1).Append(Vertices.First()))
            {
                if ((v2.Y > point.Y) != (v1.Y > point.Y) &&
                    point.X < (v1.X - v2.X) * (point.Y - v2.Y) / (v1.Y - v2.Y) + v2.X)
                {
                    inside = !inside;
                }
                v1 = v2;
            }

            return inside;
        }
    }

    public class Polygon : PolygonBase
    {
        public static Polygon GetConvex(int size, float r = 0.8f, int points = 10)
        {
            r = size * r / 2;
            List<Vector2> vertices = new List<Vector2>();
            Vector2 center = new Vector2(size / 2, size / 2);
            float step = MathF.PI * 2 / points;

            for (int i = 0; i < points; i++)
            {
                float angle = step * i;
                float dx = -r * MathF.Sin(angle);
                float dy = -r * MathF.Cos(angle);
                vertices.Add(new Vector2(center.X + dx, center.Y + dy));
            }

            return new Polygon(vertices);
        }

        public static Polygon GetStar(int size, float r1 = 0.8f, float r2 = 0.4f, int points = 10)
        {
            r2 = size * r2 / 2;
            r1 = size * r1 / 2;
            List<Vector2> vertices = new List<Vector2>();
            Vector2 center = new Vector2(size / 2, size / 2);

            for (int i = 0; i < points; i++)
            {
                float dx = -r2 * MathF.Sin(MathF.PI * 2 / points * i);
                float dy = -r2 * MathF.Cos(MathF.PI * 2 / points * i);
                vertices.Add(new Vector2(center.X + dx, center.Y + dy));

                float dx2 = -(r1 * MathF.Sin(MathF.PI * 2 / points * (i + 0.5f)));
                float dy2 = -(r1 * MathF.Cos(MathF.PI * 2 / points * (i + 0.5f)));
                vertices.Add(new Vector2(center.X + dx2, center.Y + dy2));
            }

            return new Polygon(vertices);
        }

        List<Vector2> _vertices = new List<Vector2>();
        public override IEnumerable<Vector2> Vertices => _vertices;
        public override int VertexCount => _vertices.Count;

        public Polygon(IEnumerable<Vector2> vertices)
        {
            _vertices.AddRange(vertices);
        }
    }
}
